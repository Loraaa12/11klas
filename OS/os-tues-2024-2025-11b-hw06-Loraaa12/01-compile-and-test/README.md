# Задача 1: Компилиране и тестване на C програма (175 точки)

## Описание на задачата

Напишете Bash скрипт, който автоматизира **компилирането и тестването** на C програма.
Скриптът трябва да:

1. Kомпилирa подаден `.c` файл от директорията `src/` с помощта на `gcc`. Executable
   файлът трябва да бъде записан в `bin/`.
2. Ако компилацията е успешна:
   - Стартира получения изпълним файл с **предефинирани позиционни параметри** (напр.
     `./program.out arg1 аrg2`).
   - Провери дали програмата се **изпълнява без грешка**.
3. Запише резултатите от компилацията и изпълнението в **лог файл с timestamp**.
4. Позволява задаване на `.c` файла и параметрите като аргументи на скрипта.

---

## Примерно поведение

Дaдено:

- Source файл: `main.c`
- Параметри: `10 20`

Ако `main.c` се компилира успешно:

- Скриптът изпълнява `./main.out 10 20`
- Записва в лог:
  - Успех или грешка при компилацията
  - Успех или грешка при изпълнението
  - Код на изход
  - Дата и час

---

## Изисквания към Bash скрипта

- Използване на `gcc` за компилация.
- Записване на логовете във файл в директория `logs/` (да се създава, ако не съществува).
- Като позиционни параметри към скрипта се подават:
  - Име на source файла
  - Аргументи за изпълнение на C програмата

## Автоматизация на изпълнението на тестовете

Направете GitHub Action workflow, който автоматично компилира и тества C програмата
при всяка промяна в `main.c` и `compile-and-test.sh` файловете в `main` клона в
хранилището на домашното ви.

## .gitignore

Подсигурете, че `bin/` и `logs/` директориите не се добавят в Git хранилището.

## Обяснения на полезни команди

### `shift`

Командата `shift` премахва първия позиционен аргумент (т.е. съдържанието на `$1`),
така че останалите се "преместват наляво". Това е полезно, когато искаме да работим
с аргументи **след първия**.

### `tee`

Командата `tee` чете от стандартния вход и **записва както в стандартния изход (терминала),
така и във файл**. С флага `-a` (append), тя добавя към съществуващ файл, вместо
да го презаписва.

Пример:

```bash
echo "something" | tee -a log.log
```

### `date +"%Y%m%d_%H%M%S"`

Използваме `date` със специален формат, за да генерираме timestamp, който после
използваме за именуване на логовете и изпълнимите файлове.

- `%Y` — година (напр. 2025)
- `%m` — месец (напр. 04)
- `%d` — ден
- `%H` — час (24-часов формат)
- `%M` — минута
- `%S` — секунда

Примерен резултат:

```plaintext
20250413_154210
```
