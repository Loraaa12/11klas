# Задача 1 - `molecules` (200 точки)

**Цел:**
Да се реализира симулация, в която множество процеси "Водород" (H) и "Кислород" (O) трябва да се синхронизират, за да формират молекули "Вода" (\( H_2O \)). Използвайте POSIX семафори/мютекси, за да гарантирате, че точно два H процеса и един O процес се групират заедно, за да се "свържат", преди който и да е от тях да продължи. Реализирайте това, използвайки както безименни, така и именувани семафори.

**Контекст:**
Тази задача моделира сценарий на "среща" (rendezvous), при който процеси, представляващи различни елементи, трябва да изчакат специфична комбинация от други процеси, за да станат достъпни, преди да може да се извърши съвместно действие (формиране на молекула). Това изисква внимателно управление на чакащите процеси и сигнализиране, когато е готова пълна група.

**Описание на Проблема:**
Трябва да създадете система с \( N \) процеса Водород и \( M \) процеса Кислород.

- **Процес Водород (H):** Представлява водороден атом. Той трябва да изпълни функция `bond()` _само_ когато е групиран с един друг H процес и един O процес.
- **Процес Кислород (O):** Представлява кислороден атом. Той трябва да изпълни функция `bond()` _само_ когато е групиран с два H процеса.
- **Свързване (Bonding):** Функцията `bond()` симулира формирането на водна молекула. Когато бъде извикана, процесът трябва да отпечата съобщение, указващо неговия тип (H или O), неговия PID (или ID на нишка) и уникален номер на молекула. Например: `Hydrogen <PID> bonded in molecule <ID>`. Важно е за всеки ID на молекула точно два H процеса и един O процес да отпечатат това съобщение.
- **Споделено Състояние:** Ще са ви нужни споделени променливи, за да следите броя на H и O процесите, които в момента чакат да се свържат. Ще ви трябва и споделен брояч за присвояване на уникални ID-та на молекули. Това състояние трябва да се намира в споделена памет, достъпна за всички съответни процеси/нишки.
- **Синхронизация:** Използвайте POSIX семафори (`semaphore.h`) за управление на изчакването и срещата:
  - `mutex`: Двоичен семафор (инициализиран на 1) за взаимно изключване при достъп до споделените броячи (`hydrogens_waiting`, `oxygens_waiting`, `molecule_id_counter`).
  - `hydroQueue`: Броящ семафор (инициализиран на 0), на който H процесите ще чакат, ако все още не могат да формират молекула.
  - `oxyQueue`: Броящ семафор (инициализиран на 0), на който O процесите ще чакат, ако все още не могат да формират молекула.

**Логика на Синхронизация (Насоки):**

- **Когато пристигне процес Кислород (O):**

  1. Вземете `mutex`.
  2. Увеличете броя на чакащите атоми Кислород.
  3. Проверете дали има поне 2 чакащи атома Водород.
  4. **Ако да (молекула може да се формира):**
     - Сигнализирайте `hydroQueue` два пъти (освободете 2 чакащи H атома).
     - Намалете броя на чакащите Водород с 2.
     - _Този_ атом Кислород продължава (не чака на `oxyQueue`).
     - Намалете броя на чакащите Кислород с 1.
     - Увеличете `molecule_id_counter` и запазете ID-то локално.
     - Освободете `mutex`.
     - Извикайте `bond()` със запазеното ID на молекула.
  5. **Ако не (трябва да чака):**
     - Освободете `mutex`.
     - Чакайте на `oxyQueue`.
     - _(След като бъде събуден от процес Водород)_ Извикайте `bond()`. ID-то на молекулата се подразбира от формирането на групата (може да се наложи да го предадете или просто да използвате текущата стойност на глобалния брояч _след_ събуждане, въпреки че това е по-малко надеждно). Процесът, който го събужда, вече трябва да е увеличил брояча на молекулите.

- **Когато пристигне процес Водород (H):**

  1. Вземете `mutex`.
  2. Увеличете броя на чакащите атоми Водород.
  3. Проверете дали има поне 1 _друг_ чакащ атом Водород (т.е. `hydrogens_waiting >= 2`) И поне 1 чакащ атом Кислород.
  4. **Ако да (молекула може да се формира):**
     - Сигнализирайте `hydroQueue` веднъж (освободете _другия_ чакащ H атом).
     - Намалете броя на чакащите Водород с 1 (за другия H).
     - Сигнализирайте `oxyQueue` веднъж (освободете 1 чакащ O атом).
     - Намалете броя на чакащите Кислород с 1.
     - _Този_ атом Водород продължава (не чака на `hydroQueue`).
     - Намалете броя на чакащите Водород с 1 (за себе си).
     - Увеличете `molecule_id_counter` и запазете ID-то локално.
     - Освободете `mutex`.
     - Извикайте `bond()` със запазеното ID на молекула.
  5. **Ако не (трябва да чака):**
     - Освободете `mutex`.
     - Чакайте на `hydroQueue`.
     - _(След като бъде събуден от процес Кислород или друг Водород)_ Извикайте `bond()`.

- **Функция `bond()`:** Тази функция основно отпечатва необходимото съобщение. Уверете се, че логиката за ID на молекулата е последователна.

**Задачи:**

**Част 1: Безименни Семафори (използвайки Нишки или `fork`-нати Процеси)**

1. **Реализация:**
   - Създайте една програма, която приема \( N \) (водород) и \( M \) (кислород) като аргументи от командния ред.
   - Използвайте **безименни (базирани в паметта) POSIX семафори** (`sem_init`, `sem_wait`, `sem_post`, `sem_destroy`).
   - Поставете споделените броячи (`hydrogens_waiting`, `oxygens_waiting`, `molecule_id_counter`) в памет, достъпна за всички участници.
   - Използвайте `fork()`. Поставете споделените броячи _и_ безименните семафори в регион на споделена памет (`mmap` или `shmget`/`shmat`) _преди_ `fork`-ването. Задайте `pshared` на ненулева стойност в `sem_init`. Разграничете поведението на дъщерния процес в зависимост от това дали е предназначен да бъде H или O.
2. **Логика на Синхронизация:** Реализирайте описаната по-горе логика за H и O, използвайки `sem_wait()` и `sem_post()`.
3. **Почистване:** Унищожете семафорите (`sem_destroy`) и почистете споделената памет (ако използвате Вариант Б). Уверете се, че всички нишки/процеси завършват коректно, след като се свържат веднъж.

**Част 2: Именувани Семафори (използвайки Отделни Процеси)**

1. **Реализация:**
   - Създайте главна програма, която приема \( N \) и \( M \) като аргументи.
   - Тази програма трябва да:
     - Създаде сегмент на споделена памет (`shmget`/`shmat` или `mmap` с файл) за споделените броячи. Инициализирайте броячите на 0.
     - Създаде и инициализира **именувани POSIX семафори** (`sem_open`, `sem_unlink`) за `mutex`, `hydroQueue`, `oxyQueue`. Използвайте уникални имена (напр. "/h2oMutex", "/h2oHydroQueue", "/h2oOxyQueue").
     - Стартира \( N \) процеса Водород и \( M \) процеса Кислород (напр. използвайки `fork()` и `exec()`, предавайки ID/ключ на споделената памет, имената на семафорите и типа на процеса 'H'/'O' чрез аргументи).
     - Изчака завършването на всички дъщерни процеси.
   - **Процеси Водород/Кислород:** Отделни процеси (или един изпълним файл, разграничен чрез аргументи), които:
     - Се прикачат към сегмента на споделена памет.
     - Отварят именуваните семафори (`sem_open` без `O_CREAT`).
     - Изпълняват съответната H или O логика за синхронизация.
     - Извикват `bond()`.
     - Затварят семафорите (`sem_close`) и се откачат от споделената памет (`shmdt` или `munmap`).
2. **Логика на Синхронизация:** Основната логика остава същата като в Част 1.
3. **Почистване:** Първоначалният процес трябва да премахне връзките към именуваните семафори (`sem_unlink`) и да премахне сегмента на споделена памет (`shmctl` или `shm_unlink`) _след_ като всички дъщерни процеси приключат.

**Подсказки:**

- Процесът, който открие възможност за формиране на молекула, е отговорен за събуждането на _другите_ необходими процеси.
- Защитете _всеки_ достъп/модификация на споделените броячи с `mutex`.
- Бъдете внимателни кога се освобождава `mutex`, особено когато процес трябва да чака. Той трябва да бъде освободен _преди_ извикването на `sem_wait` за `hydroQueue` или `oxyQueue`.
- Уверете се, че ID-то на молекулата се присвоява атомарно (в рамките на заключването с `mutex`) и се използва последователно от трите свързващи се партньора.
- Проверявайте връщаните стойности от всички системни/семафорни извиквания.
